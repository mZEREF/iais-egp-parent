/*
 * MyInfo TUO RESTAPI (Staging)
 * ** STAGING ENVIRONMENT ONLY **  REST API for retrieving Person data from MyInfo for Tell-Us-Once.  **Note - this is an initial specification and is subject to changes through the course of the TUO implementation.**
 *
 * OpenAPI spec version: 1.0
 * Contact: eric_chang@tech.gov.sg
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.ecquaria.cloud.moh.iais.model;


import com.ecquaria.cloud.helper.ConfigHelper;
import com.ecquaria.cloud.helper.SpringContextHelper;
import com.ecquaria.cloud.moh.iais.auth.MyInfoClient;
import com.ecquaria.cloud.moh.iais.common.constant.AuditTrailConsts;
import com.ecquaria.cloud.moh.iais.common.constant.acra.AcraConsts;
import com.ecquaria.cloud.moh.iais.common.dto.AuditTrailDto;
import com.ecquaria.cloud.moh.iais.common.dto.myinfo.GetTokenDto;
import com.ecquaria.cloud.moh.iais.common.dto.myinfo.MyInfoTakenDto;
import com.ecquaria.cloud.moh.iais.common.jwt.SignatureUtil;
import com.ecquaria.cloud.moh.iais.common.utils.IaisCommonUtils;
import com.ecquaria.cloud.moh.iais.common.utils.JsonUtil;
import com.ecquaria.cloud.moh.iais.common.utils.StringUtil;
import com.ecquaria.cloud.moh.iais.helper.AuditTrailHelper;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.ApplicationContext;
import org.springframework.http.CacheControl;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.HttpClientErrorException;


/**
 * API tests for MyinfoTuoRestfulApi
 */
@Slf4j
public class MyinfoUtil {

	public static final String KEY_MYINFO_TAKEN_START_TIME = "keyStartTime_";
	public static  final String KEY_MYINFO_TAKEN = "myinfo_token_";
	public static  final String KEY_TAKEN_TYPE ="token_type";
	public static  final String MYINFODTO_REFRESH = "myinfoDto_refresh";
	public static  final long TAKEN_DURATION_TIME = 30*60*1000l;;

	public static final  String CALL_MYINFO_PROCESS_SESSION_NAME = "call_myinfo_process_session_name";
	public static final  String CALL_MYINFO_PROCESS_SESSION_NAME_NRIC = "call_myinfo_process_session_name_nric";
	public static final  String CALL_MYINFO_DTO_SEESION                     = "call_myinfo_dto_seesion";
	public static final  String SOLO_DTO_SEESION = "myinfo_solo_dto_seesion";
	public static final  String SOLO_DTO_SEESION_ACTION = "saveSoleAction";
	public static final  String MYINFO_TRANSFER_CALL_BACK = "myinfo_transfer_call_back";
	public static final  String SINGPASS_LOGIN                = "myinfo_sinpass_login_evaluate";
	public static final  String NO_GET_NAME_SHOW_NAME           = "-";

	public static final  String CLEAR_MYINFO_ACTION = "clearMyInfo";

	public static final  String IS_LOAD_MYINFO_DATA  = "isLoadMyInfoData";
	/**
	 * Retrieves Person data from MyInfo
	 *
	 * Retrieves Person data from MyInfo based on UIN/FIN. This API does not require authorisation token, and retrieves only a user&#39;s basic profile (i.e. excluding CPF and IRAS data)  The available returned attributes from this API includes  - name: Name - hanyupinyinname: HanYuPinYin - aliasname: Alias - hanyupinyinaliasname: HanYuPinYinAlias - marriedname: MarriedName - sex: Sex - race: Race - dialect: Dialect - nationality: Nationality - dob: DOB - birthcountry: BirthCountry - vehno: VehNo - regadd: RegAdd - mailadd: MailAdd - billadd: BillAdd - housingtype: HousingType - hdbtype: HDBType - email: Email - homeno: HomeNo - mobileno: MobileNo - marital: Marital - marriagedate: MarriageDate - divorcedate: DivorceDate - householdincome: HouseholdIncome - relationships: Relationships - edulevel: EduLevel - gradyear: GradYear - schoolname: SchoolName - occupation: Occupation - employment: Employment  Note - null values indicate that the field is unavailable
	 * @throws Exception
	 */
	public static String getPersonBasic( String authorization,String idNumber,List<String> attributes,String clientId,String singPassEServiceId,String txnNo) throws Exception {
		ApplicationContext context = SpringContextHelper.getContext();
		if (context == null){
			return null;
		}

		MyInfoClient myInfoClient = context.getBean(MyInfoClient.class);

		String  encipheredData =myInfoClient.searchDataByIdNumber(authorization,idNumber,attributes.toArray(new String[attributes.size()]),clientId,singPassEServiceId,txnNo).getBody();
		return decodeEncipheredData(encipheredData);
	}

	public static String decodeEncipheredData(String encipheredData) throws Exception {
		if(StringUtil.isEmpty(encipheredData)){
			return encipheredData;
		}

		String privateKey = ConfigHelper.getString("myinfo.common.priclientkey");

		return SignatureUtil.decryptToken(encipheredData, privateKey).getPayload().toString();
	}

	public static String getBaseString( String idNum, List<String> attrs, String clientId, String singpassEserviceId, String txnNo){
		StringBuilder sb = new StringBuilder();
		String ipAddress = ConfigHelper.getString("myinfo.ip.address.basestring.gateway");
		sb.append("GET&").append(ipAddress);
		String idnum = "/" + idNum + "/";
		sb.append(idnum);
		sb.append("?attributes=");
		if (attrs.size() > 0) {
			for (int i = 0; i < attrs.size(); i++) {
				if (i == (attrs.size() - 1)) {
					sb.append(attrs.get(i));
				} else {
					sb.append(attrs.get(i)).append(',');
				}
			}
		}
		sb.append("&client_id=").append(clientId);
		sb.append("&singpassEserviceId=").append(singpassEserviceId);
		sb.append("&txnNo=").append(txnNo);
		return sb.toString();
	}

	public static String getAuthorization(String realm, String signature, String appId, long nonce, long timestamp) {
		StringBuilder sb = new StringBuilder();
		sb.append("Apex_l2_Eg realm=\"").append(realm );
		sb.append("\",apex_l2_eg_app_id=\"").append(appId);
		sb.append("\",apex_l2_eg_nonce=\"").append(nonce);
		sb.append("\",apex_l2_eg_signature_method=\"SHA256withRSA\"");
		sb.append(",apex_l2_eg_signature=\"").append(signature);
		sb.append("\",apex_l2_eg_timestamp=\"").append(timestamp);
		sb.append("\",apex_l2_eg_version=\"1.0\"");
		return sb.toString();
	}

	public static String  getAuthorization(String method, String clientId,List<String> attrs, String privateKeyPEM,String appId,String requestUrl) throws NoSuchAlgorithmException {
		String attribute = getAttrsStringByListAttrs(attrs);
		String timestamp = String.valueOf(new Date().getTime());
		SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG");
		String nonceValue = timestamp +	(secureRandom.nextInt(9000) + 1000);
		TreeMap<String, String> baseParams = new TreeMap<>();
		baseParams.put(AcraConsts.APP_ID + "=", appId);
		baseParams.put(AcraConsts.CLIENT_ID + "=", clientId);
		baseParams.put(AcraConsts.ATTRIBUTE + "=", attribute);
		baseParams.put(AcraConsts.TIMESTAMP + "=", timestamp);
		baseParams.put(AcraConsts.NONCE + "=", nonceValue);
		baseParams.put(AcraConsts.SIGNATURE_METHOD + "=","SHA256withRSA");
		String baseString = SignatureUtil.generateBaseString(method, requestUrl, baseParams);
		String signature =  SignatureUtil.generateSignature(baseString, privateKeyPEM);
		TreeMap<String, String> authHeaderParams = new TreeMap<>();
		authHeaderParams.put(AcraConsts.TIMESTAMP + "=", timestamp);
		authHeaderParams.put(AcraConsts.NONCE + "=", nonceValue);
		authHeaderParams.put(AcraConsts.APP_ID + "=", appId);
		authHeaderParams.put(AcraConsts.SIGNATURE_METHOD + "=", "SHA256withRSA");
		authHeaderParams.put(AcraConsts.SIGNATURE + "=", signature);
		return SignatureUtil.generateAuthorizationHeader(authHeaderParams);
	}


	public static  Map<String,String> getSessionForMyInfoTaken(String nirc, String taken,String takenType){
		Map<String,String> map = new HashMap<>(3);
		map.put(KEY_MYINFO_TAKEN+nirc,taken);
		map.put(KEY_MYINFO_TAKEN+nirc+KEY_TAKEN_TYPE,taken);
		map.put(KEY_MYINFO_TAKEN_START_TIME+nirc,String.valueOf(new Date().getTime()));
		return  map;
	}


	public static  Map<String,String> clearSessionForMyInfoTaken(String nirc){
		Map<String,String> map = new HashMap<>(3);
		map.put(KEY_MYINFO_TAKEN+nirc,null);
		map.put(KEY_MYINFO_TAKEN+nirc+KEY_TAKEN_TYPE,null);
		map.put(KEY_MYINFO_TAKEN_START_TIME+nirc,null);
		return  map;
	}

	public static String getAuthoriseApiUrl(String authApiUrl,String nric,String clientId,String attributes,String spEsvcId,String purpose,String state,String redirectUrl){
		String authoriseUrl = authApiUrl + "/" + nric + "/"+
				"?client_id=" + clientId +
				"&attributes=" + attributes +
				"&sp_esvcId=" + spEsvcId +
				"&purpose=" + purpose +
				"&redirect_uri=" + redirectUrl+
				"&state=" + state;
		return authoriseUrl;
	}


	public static String getAttrsStringByListAttrs( List<String> attrs){
		StringBuilder sb = new StringBuilder();
		if( !IaisCommonUtils.isEmpty(attrs)){
			for (int i = 0; i < attrs.size(); i++) {
				if (i == (attrs.size() - 1)) {
					sb.append(attrs.get(i));
				} else {
					sb.append(attrs.get(i)).append(',');
				}
			}
		}
		return sb.toString();
	}


	public static  String generateAuthorizationHeaderForMyInfo(String method, String clientId, String attribute, String privateKeyPEM,String spEsvcId,String requestUrl,String takenType,String validToken){
		String timestamp = String.valueOf(System.currentTimeMillis());
		String nonceValue;
		try{
			SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG");
			nonceValue = timestamp + (secureRandom.nextInt(9000) + 1000);
		}catch (Exception e){
			log.error(e.getMessage(),e);
			nonceValue = timestamp;
		}
		String appId = ConfigHelper.getString("myinfo.common.app.id", clientId);
		TreeMap<String, String> baseParams = new TreeMap<>();
		baseParams.put(AcraConsts.APP_ID + "=", appId);
		baseParams.put(AcraConsts.SIGNATURE_METHOD + "=", "RS256");
		baseParams.put(AcraConsts.CLIENT_ID + "=", clientId);
		baseParams.put(AcraConsts.ATTRIBUTE + "=", attribute);
		baseParams.put(AcraConsts.TIMESTAMP + "=", timestamp);
		baseParams.put(AcraConsts.NONCE + "=", nonceValue);
		baseParams.put(AcraConsts.SP_ESVCID + "=", spEsvcId);
		String baseString = SignatureUtil.generateBaseString(method, requestUrl, baseParams);
		log.info(StringUtil.changeForLog("Myinfo person base string => " + baseString));
		String signature =  SignatureUtil.generateSignature(baseString, privateKeyPEM);
		log.info(StringUtil.changeForLog("Myinfo person signature => " + signature));
		TreeMap<String, String> authHeaderParams = new TreeMap<>();
		authHeaderParams.put(AcraConsts.TIMESTAMP + "=", timestamp);
		authHeaderParams.put(AcraConsts.NONCE + "=", nonceValue);
		authHeaderParams.put(AcraConsts.APP_ID + "=", clientId);
		authHeaderParams.put(AcraConsts.SIGNATURE_METHOD + "=", "RS256");
		authHeaderParams.put(AcraConsts.SIGNATURE + "=", signature);
		return SignatureUtil.generateAuthorizationHeader(authHeaderParams) +  ','+ takenType + " " + validToken;
	}

	public static String generateAuthorizationHeaderForMyInfoTaken(String method, String grantType, String code, String privateKeyPEM,String clientSecret,String requestUrl,String clientId,String state,String redirectUri) throws NoSuchAlgorithmException {
		log.info(StringUtil.changeForLog("---------generateAuthorizationHeaderForMyInfoTaken state = "+ state));
		String authlevel = ConfigHelper.getString("myinfo.common.authlevel","L2");
		if(!authlevel .equalsIgnoreCase("L2")){
			return "";
		}
		String appId = ConfigHelper.getString("myinfo.common.app.id", clientId);
		String timestamp = String.valueOf(System.currentTimeMillis());
		SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG");
		String nonce = timestamp +	(secureRandom.nextInt(9000) + 1000);
		TreeMap<String, String> baseParams = new TreeMap<>();
		baseParams.put(AcraConsts.GRANT_TYPE + "=", grantType);
		baseParams.put(AcraConsts.CODE + "=", code);
		baseParams.put(AcraConsts.REDIRECT_URI + "=", redirectUri);
		baseParams.put(AcraConsts.CLIENT_ID + "=", clientId);
		baseParams.put(AcraConsts.CLIENT_SECRET + "=", clientSecret);
		baseParams.put("app_id=", appId);
		baseParams.put("nonce=", nonce);
		baseParams.put(AcraConsts.SIGNATURE_METHOD + "=", "RS256");
		baseParams.put("timestamp=", timestamp);
		baseParams.put("state=", state);
		String baseString = SignatureUtil.generateBaseString(method, requestUrl, baseParams);
		log.info(StringUtil.changeForLog("Token auth base string ==> " + baseString));
		String signature =  SignatureUtil.generateSignature(baseString, privateKeyPEM);
		log.info(StringUtil.changeForLog("Token auth signature ==> " + signature));
		TreeMap<String, String> authHeaderParams = new TreeMap<>();
		authHeaderParams.put("app_id=", appId);
		authHeaderParams.put("nonce=", nonce);
		authHeaderParams.put(AcraConsts.SIGNATURE + "=", signature);
		authHeaderParams.put(AcraConsts.SIGNATURE_METHOD + "=", "RS256");
		authHeaderParams.put("timestamp=", timestamp);

		return SignatureUtil.generateAuthorizationHeader(authHeaderParams);
	}

	public static MyInfoTakenDto getTakenCallMyInfo(String method, String grantType, String code, String privateKeyPEM, String clientSecret, String requestUrl, String clientId, String state, String redirectUri) throws NoSuchAlgorithmException {
		GetTokenDto getTokenDto = new GetTokenDto(code,grantType,clientSecret,clientId,redirectUri,state);
		String authorizationHeader = generateAuthorizationHeaderForMyInfoTaken(method, grantType, code, privateKeyPEM, clientSecret, requestUrl, clientId, state, redirectUri);
		if(StringUtil.isEmpty(authorizationHeader)){
			log.info("--------getTakenCallMyInfo authorizationHeader is null-------------");
			return null;
		} else {
			log.info(StringUtil.changeForLog("Token Auth Header ==> " + authorizationHeader));
		}
		ResponseEntity<MyInfoTakenDto> resEntity;
		HttpHeaders header = new HttpHeaders();
		header.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
		header.setCacheControl(CacheControl.noCache());
		header.set("Authorization", authorizationHeader);
		HttpStatus httpStatus;
		try {
			String eicUrl = ConfigHelper.getString("myinfo.taken.requestUrl",requestUrl);
			resEntity = IaisCommonUtils.callEicGatewayWithBody(eicUrl , HttpMethod.POST,handleRequestBody(getTokenDto),null, header,MyInfoTakenDto.class,null);
			AuditTrailDto auditTrailDto = new AuditTrailDto();
			auditTrailDto.setOperation(AuditTrailConsts.OPERATION_FOREIGN_INTERFACE);
			auditTrailDto.setOperationType(AuditTrailConsts.OPERATION_TYPE_INTERNET);
			auditTrailDto.setModule("MyInfo");
			auditTrailDto.setFunctionName("getTakenCallMyInfo");
			auditTrailDto.setBeforeAction(JsonUtil.parseToJson(getTokenDto));
			auditTrailDto.setAfterAction(JsonUtil.parseToJson(resEntity));
			AuditTrailHelper.callSaveAuditTrail(auditTrailDto);
			httpStatus = resEntity.getStatusCode();
			if( httpStatus == HttpStatus.OK){
				return resEntity.getBody();
			}else {
				return null;
			}
		}catch (HttpClientErrorException e){
			log.error(e.getMessage(), e);
			return null;
		}

	}

	private static MultiValueMap<String, String> handleRequestBody(GetTokenDto getTokenDto) {
		MultiValueMap<String, String> newMap = new LinkedMultiValueMap<>();
		newMap.add("code", getTokenDto.getCode());
		newMap.add("grant_type", getTokenDto.getGrant_type());
		newMap.add("client_secret", getTokenDto.getClient_secret());
		newMap.add("client_id", getTokenDto.getClient_id());
		newMap.add("redirect_uri", getTokenDto.getRedirect_uri());
		newMap.add("state", getTokenDto.getState());
		return newMap;
	}
}
